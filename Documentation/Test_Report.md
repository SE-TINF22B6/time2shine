# time2shine
## Test Report

### 1. Introduction
We devided our project in two components:
1. Frontend
2. Backend

Each component necessitates its own testing methodology, as they target different aspects. These methodologies will be explained in more detail in the next section. We utilize the following testing software to achieve our objectives:
- Frontend
  - React Testing Library
- Backend
  - JUnit5
  - CodeQL

### 2. Test Strategy
#### Frontend
For our frontend development, we want to employ a comprehensive pipeline designed to validate the integrity and error-free functionality of each build. To ensure the robustness of our frontend, we prioritize extensive testing through real user interactions, allowing us to capture and address issues that may arise in practical usage scenarios.

#### Backend
We aim to maintain a dedicated pipeline for our backend to ensure the integrity and error-free performance of each build. Integration tests will also play a crucial role in our project. For our games, developed using the JavaScript library pixi.js, we need to establish effective testing methods, as pixi.js lacks built-in testing capabilities. Therefore, we plan to use JEST or Mocha to facilitate this process.

### 3. Test Plan
To achieve our testing objectives, we need to set up the previously mentioned libraries, 'JUnit5' and 'React Testing Library'. Additionally, we must integrate pipelines for both our backend and frontend. For our pixi.js library, we plan to create tests using JEST.

### 4. Test Cases
We have some tests for our database. Which are looking like this:
![image](https://github.com/SE-TINF22B6/time2shine/assets/122756244/7a313f1f-8c57-4c3f-bf36-a7a80111e043)

> This section details the specific test cases that were executed, including their pass/fail status and any defects found during testing. (You may link to the repository of your use cases.)

### 5. Test Results 
This section summarizes the results of the testing, including major defects found, their severity, and the steps taken to resolve them. (You may link to the test reports generated by your testing tool.)
The image below shows all our pipelines functioning correctly. We've included a specific pipeline to verify the correct deployment of our game engine (pixi.js). Additionally, we've integrated CodeQL to detect vulnerabilities, bugs, and other potential issues in our code.

![image](https://github.com/SE-TINF22B6/time2shine/assets/122756244/d5bde10b-f93a-4d57-8eca-6b85698e8729)

Unfortunately, we encountered error messages when attempting to test the pixi.js code with JEST or Mocha, which are beyond our control. Therefore, we depend on feedback from users and developers to ensure everything is functioning correctly in our games.

### 6. Metrics
In the following image, you can observe that our test coverage stands at 100%. However, due to limitations in testing our games and the comprehensive coverage of our frontend with the 'React Testing Library', we currently only have ten tests. Consequently, our database, which is not extensive, accounts for the majority of these tests.
![image](https://github.com/SE-TINF22B6/time2shine/assets/122756244/24528ee2-800a-428a-a680-5bfeb94d6489)

### 7. Recommendations
While our current tests can confirm that components function correctly under specific conditions, it remains crucial to use our actual product as extensively as possible. The majority of bugs and errors are discovered through real interactions with the website and by simulating actual client usage. Stress tests are also valuable for assessing whether our database and backend can handle multiple concurrent requests while maintaining data coherence.

### 8. Conclusion
- Manual testing is really important and helpfull, especially for our frontend and our games
- It's really important to write the tests parallel to the code
- Use atomic test (test focusses only on one thing) to easily find and handle errors


