# time2shine
## Test Report

### 1. Introduction
We devided our project in two components:
1. Frontend
2. Backend

Each component necessitates its own testing methodology, as they target different aspects. These methodologies will be explained in more detail in the next section. We utilize the following testing software to achieve our objectives:
- Frontend
  - React Testing Library
- Backend
  - JUnit5
  - SpringFramework Libraries

### 2. Test Strategy
#### Frontend
For our frontend development, we want to employ a comprehensive pipeline designed to validate the integrity and error-free functionality of each build. To ensure the robustness of our frontend, we prioritize extensive testing through real user interactions, allowing us to capture and address issues that may arise in practical usage scenarios.

#### Backend
We aim to maintain a dedicated pipeline for our backend to ensure the integrity and error-free performance of each build. Integration tests will also play a crucial role in our project. For our games, developed using the JavaScript library pixi.js, we need to establish effective testing methods, as pixi.js lacks built-in testing capabilities. Therefore, we plan to use JEST to facilitate this process.

Unfortunately, extensive automated testing for our backend is limited due to our use of the JavaScript library pixi.js for our games, which lacks built-in testing methods. Consequently, we rely heavily on user interactions to verify that our games function correctly.

### 3. Test Plan
To achieve our testing objectives, we need to set up the previously mentioned libraries, 'JUnit5' and 'React Testing Library'. Additionally, we must integrate pipelines for both our backend and frontend. For our pixi.js library, we plan to create tests using JEST.

### 4. Test Cases
> This section details the specific test cases that were executed, including their pass/fail status and any defects found during testing. (You may link to the repository of your use cases.)

### 5. Test Results 
This section summarizes the results of the testing, including major defects found, their severity, and the steps taken to resolve them. (You may link to the test reports generated by your testing tool.)
The image below shows all our pipelines functioning correctly. We've included a specific pipeline to verify the correct deployment of our game engine (pixi.js). Additionally, we've integrated CodeQL to detect vulnerabilities, bugs, and other potential issues in our code.
![image](https://github.com/SE-TINF22B6/time2shine/assets/122756244/d5bde10b-f93a-4d57-8eca-6b85698e8729)

### 6. Metrics
> This section provides quantitative data on the testing process, such as the number of defects found, the defect resolution time, and the test coverage achieved.

### 7. Recommendations
While our current tests can confirm that components function correctly under specific conditions, it remains crucial to use our actual product as extensively as possible. The majority of bugs and errors are discovered through real interactions with the website and by simulating actual client usage. Stress tests are also valuable for assessing whether our database and backend can handle multiple concurrent requests while maintaining data coherence.

### 8. Conclusion
> This section summarizes the key findings of the testing and the overall status of the software quality.

